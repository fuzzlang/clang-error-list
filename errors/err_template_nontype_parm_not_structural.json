{
  "id": "err_template_nontype_parm_not_structural",
  "description": "This error occurs when a non-type template parameter has a type that is not allowed for non-type template parameters. Before C++20, class types were not allowed as non-type template parameters. In C++20, only structural types are allowed.",
  "exampleCode": "template<_Atomic int ci> struct AtomicInt; // expected-error {{cannot have type '_Atomic(int)'}}\n\ntypedef __attribute__((ext_vector_type(4))) int VI4;\ntypedef __attribute__((ext_vector_type(4))) float VF4;\ntemplate<VI4> struct VectorInt; // cxx17-error {{cannot have type 'VI4'}}\ntemplate<VF4> struct VectorFloat; // cxx17-error {{cannot have type 'VF4'}}\n\nstruct A2 {};\n\nstruct RRef {\n  int &&r; // cxx20-note 1+{{'RRef' is not a structural type because it has a non-static data member of rvalue reference type}}\n};\n\n// class types with all public members and bases, no mutable state, and no rvalue references.\nstruct B : A, public A2 {\n  int a;\nprivate:\n  void f();\n  static int s;\npublic:\n  float g;\n  int &r = a;\n  void *p;\n  A2 a2;\n  RRef *ptr_to_bad;\n  RRef &ref_to_bad = *ptr_to_bad;\n  _Complex int ci;\n  _Complex float cf;\n  _BitInt(42) ei;\n  VI4 vi4;\n  VF4 vf4;\n};\n\ntemplate<B> struct ClassNTTP {}; // cxx17-error {{cannot have type 'B'}}\n\ntemplate<RRef> struct WithRRef {}; // cxx17-error {{cannot have type 'RRef'}}",
  "explanation": "The error occurs because non-type template parameters cannot have certain types. Before C++20, class types like 'B' were not allowed as non-type template parameters. In C++20, only structural types (types that can be compared for equality by comparing their underlying bits) are allowed.",
  "fixedCode": "// For C++20 and later, ensure B is a structural type:\nstruct B {\n  int a;\n  float g;\n  \n  // Add comparison operators for structural equality\n  bool operator==(const B&) const = default;\n};\n\ntemplate<B b> struct ClassNTTP { /* ... */ };"
} 